var Ye = Object.defineProperty;
var Ee = (e) => {
  throw TypeError(e);
};
var et = (e, s, t) => s in e ? Ye(e, s, { enumerable: !0, configurable: !0, writable: !0, value: t }) : e[s] = t;
var l = (e, s, t) => et(e, typeof s != "symbol" ? s + "" : s, t), Se = (e, s, t) => s.has(e) || Ee("Cannot " + t);
var B = (e, s, t) => (Se(e, s, "read from private field"), t ? t.call(e) : s.get(e)), $e = (e, s, t) => s.has(e) ? Ee("Cannot add the same private member more than once") : s instanceof WeakSet ? s.add(e) : s.set(e, t), ke = (e, s, t, n) => (Se(e, s, "write to private field"), n ? n.call(e, t) : s.set(e, t), t);
const tt = "host", xe = "queue/data", st = "queue/join", Re = "upload", nt = "login", X = "config", it = "info", ot = "runtime", rt = "sleeptime", at = "heartbeat", ct = "component_server", ut = "reset", lt = "cancel", pt = "app_id", Ie = "This application is currently busy. Please try again. ", V = "Connection errored out. ", x = "Could not resolve app config. ", ht = "Could not get space status. ", ft = "Could not get API info. ", he = "Space metadata could not be loaded. ", dt = "Invalid URL. A full URL path is required.", _t = "Not authorized to access this space. ", Pe = "Invalid credentials. Could not login. ", gt = "Login credentials are required to access this space.", mt = "File system access is only available in Node.js environments", Ue = "Root URL not found in client config", wt = "Error uploading file";
async function Oe(e, s, t) {
  try {
    return (await (await fetch(`https://huggingface.co/api/spaces/${e}/jwt`, {
      headers: {
        Authorization: `Bearer ${s}`,
        ...t ? { Cookie: t } : {}
      }
    })).json()).token || !1;
  } catch {
    return !1;
  }
}
function yt(e) {
  let s = {};
  return e.forEach(({ api_name: t, id: n }) => {
    t && (s[t] = n);
  }), s;
}
async function bt(e) {
  const s = this.options.token ? { Authorization: `Bearer ${this.options.token}` } : {};
  if (s["Content-Type"] = "application/json", typeof window < "u" && window.gradio_config && location.origin !== "http://localhost:9876") {
    if (window.gradio_config.current_page && (e = e.substring(0, e.lastIndexOf("/"))), window.gradio_config.dev_mode) {
      let t = le(
        e,
        this.deep_link ? X + "?deep_link=" + this.deep_link : X
      );
      const n = await this.fetch(t, {
        headers: s,
        credentials: "include"
      }), i = await Te(
        n,
        e,
        !!this.options.auth
      );
      window.gradio_config = {
        ...i,
        current_page: window.gradio_config.current_page
      };
    }
    return window.gradio_config.root = e, { ...window.gradio_config };
  } else if (e) {
    let t = le(
      e,
      this.deep_link ? X + "?deep_link=" + this.deep_link : X
    );
    const n = await this.fetch(t, {
      headers: s,
      credentials: "include"
    });
    return Te(n, e, !!this.options.auth);
  }
  throw new Error(x);
}
async function Te(e, s, t) {
  var n, i;
  if ((e == null ? void 0 : e.status) === 401 && !t) {
    const r = await e.json(), o = (n = r == null ? void 0 : r.detail) == null ? void 0 : n.auth_message;
    throw new Error(o || gt);
  } else if ((e == null ? void 0 : e.status) === 401 && t)
    throw new Error(Pe);
  if ((e == null ? void 0 : e.status) === 200) {
    let r = await e.json();
    return r.root = s, (i = r.dependencies) == null || i.forEach((o, a) => {
      o.id === void 0 && (o.id = a);
    }), r;
  } else if ((e == null ? void 0 : e.status) === 401)
    throw new Error(_t);
  throw new Error(x);
}
async function vt() {
  const { http_protocol: e, host: s } = await de(
    this.app_reference,
    this.options.token
  );
  try {
    if (this.options.auth) {
      const t = await je(
        e,
        s,
        this.options.auth,
        this.fetch,
        this.options.token
      );
      t && this.set_cookies(t);
    }
  } catch (t) {
    throw Error(t.message);
  }
}
async function je(e, s, t, n, i) {
  const r = new FormData();
  r.append("username", t == null ? void 0 : t[0]), r.append("password", t == null ? void 0 : t[1]);
  let o = {};
  i && (o.Authorization = `Bearer ${i}`);
  const a = await n(`${e}//${s}/${nt}`, {
    headers: o,
    method: "POST",
    body: r,
    credentials: "include"
  });
  if (a.status === 200)
    return a.headers.get("set-cookie");
  throw a.status === 401 ? new Error(Pe) : new Error(he);
}
function ue(e) {
  if (e.startsWith("http")) {
    const { protocol: s, host: t, pathname: n } = new URL(e);
    return {
      ws_protocol: s === "https:" ? "wss" : "ws",
      http_protocol: s,
      host: t + (n !== "/" ? n : "")
    };
  }
  return {
    ws_protocol: "wss",
    http_protocol: "https:",
    host: new URL(e).host
  };
}
const qe = (e) => {
  let s = [];
  return e.split(/,(?=\s*[^\s=;]+=[^\s=;]+)/).forEach((n) => {
    const [i, r] = n.split(";")[0].split("=");
    i && r && s.push(`${i.trim()}=${r.trim()}`);
  }), s;
}, fe = /^[a-zA-Z0-9_\-\.]+\/[a-zA-Z0-9_\-\.]+$/, Et = /.*hf\.space\/{0,1}.*$/;
async function de(e, s) {
  const t = {};
  s && (t.Authorization = `Bearer ${s}`);
  const n = e.trim().replace(/\/$/, "");
  if (fe.test(n))
    try {
      const r = (await (await fetch(
        `https://huggingface.co/api/spaces/${n}/${tt}`,
        { headers: t }
      )).json()).host;
      return {
        space_id: e,
        ...ue(r)
      };
    } catch {
      throw new Error(he);
    }
  if (Et.test(n)) {
    const { ws_protocol: i, http_protocol: r, host: o } = ue(n);
    return {
      space_id: o.split("/")[0].replace(".hf.space", ""),
      ws_protocol: i,
      http_protocol: r,
      host: o
    };
  }
  return {
    space_id: !1,
    ...ue(n)
  };
}
const le = (...e) => {
  try {
    return e.reduce((s, t) => (s = s.replace(/\/+$/, ""), t = t.replace(/^\/+/, ""), new URL(t, s + "/").toString()));
  } catch {
    throw new Error(dt);
  }
};
function St(e, s, t) {
  const n = {
    named_endpoints: {},
    unnamed_endpoints: {}
  };
  return Object.keys(e).forEach((i) => {
    (i === "named_endpoints" || i === "unnamed_endpoints") && (n[i] = {}, Object.entries(e[i]).forEach(
      ([r, { parameters: o, returns: a }]) => {
        var p, g, v, P;
        const u = ((p = s.dependencies.find(
          (c) => c.api_name === r || c.api_name === r.replace("/", "")
        )) == null ? void 0 : p.id) || t[r.replace("/", "")] || -1, h = u !== -1 ? (g = s.dependencies.find((c) => c.id == u)) == null ? void 0 : g.types : { generator: !1, cancel: !1 };
        if (u !== -1 && ((P = (v = s.dependencies.find((c) => c.id == u)) == null ? void 0 : v.inputs) == null ? void 0 : P.length) !== o.length) {
          const c = s.dependencies.find((_) => _.id == u).inputs.map(
            (_) => {
              var S;
              return (S = s.components.find((R) => R.id === _)) == null ? void 0 : S.type;
            }
          );
          try {
            c.forEach((_, S) => {
              if (_ === "state") {
                const R = {
                  component: "state",
                  example: null,
                  parameter_default: null,
                  parameter_has_default: !0,
                  parameter_name: null,
                  hidden: !0
                };
                o.splice(S, 0, R);
              }
            });
          } catch (_) {
            console.error(_);
          }
        }
        const f = (c, _, S, R) => ({
          ...c,
          description: kt(c == null ? void 0 : c.type, S),
          type: $t(c == null ? void 0 : c.type, _, S, R) || ""
        });
        n[i][r] = {
          parameters: o.map(
            (c) => f(c, c == null ? void 0 : c.component, c == null ? void 0 : c.serializer, "parameter")
          ),
          returns: a.map(
            (c) => f(c, c == null ? void 0 : c.component, c == null ? void 0 : c.serializer, "return")
          ),
          type: h
        };
      }
    ));
  }), n;
}
function $t(e, s, t, n) {
  if (s === "Api") return e.type;
  switch (e == null ? void 0 : e.type) {
    case "string":
      return "string";
    case "boolean":
      return "boolean";
    case "number":
      return "number";
  }
  if (t === "JSONSerializable" || t === "StringSerializable")
    return "any";
  if (t === "ListStringSerializable")
    return "string[]";
  if (s === "Image")
    return n === "parameter" ? "Blob | File | Buffer" : "string";
  if (t === "FileSerializable")
    return (e == null ? void 0 : e.type) === "array" ? n === "parameter" ? "(Blob | File | Buffer)[]" : "{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}[]" : n === "parameter" ? "Blob | File | Buffer" : "{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}";
  if (t === "GallerySerializable")
    return n === "parameter" ? "[(Blob | File | Buffer), (string | null)][]" : "[{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}, (string | null))][]";
}
function kt(e, s) {
  return s === "GallerySerializable" ? "array of [file, label] tuples" : s === "ListStringSerializable" ? "array of strings" : s === "FileSerializable" ? "array of files or single file" : e == null ? void 0 : e.description;
}
function Ae(e, s) {
  switch (e.msg) {
    case "send_data":
      return { type: "data" };
    case "send_hash":
      return { type: "hash" };
    case "queue_full":
      return {
        type: "update",
        status: {
          queue: !0,
          message: Ie,
          stage: "error",
          code: e.code,
          success: e.success
        }
      };
    case "heartbeat":
      return {
        type: "heartbeat"
      };
    case "unexpected_error":
      return {
        type: "unexpected_error",
        status: {
          queue: !0,
          message: e.message,
          session_not_found: e.session_not_found,
          stage: "error",
          success: !1
        }
      };
    case "broken_connection":
      return {
        type: "broken_connection",
        status: {
          queue: !0,
          message: e.message,
          stage: "error",
          success: !1
        }
      };
    case "estimation":
      return {
        type: "update",
        status: {
          queue: !0,
          stage: s || "pending",
          code: e.code,
          size: e.queue_size,
          position: e.rank,
          eta: e.rank_eta,
          success: e.success
        }
      };
    case "progress":
      return {
        type: "update",
        status: {
          queue: !0,
          stage: "pending",
          code: e.code,
          progress_data: e.progress_data,
          success: e.success
        }
      };
    case "log":
      return { type: "log", data: e };
    case "process_generating":
      return {
        type: "generating",
        status: {
          queue: !0,
          message: e.success ? null : e.output.error,
          stage: e.success ? "generating" : "error",
          code: e.code,
          progress_data: e.progress_data,
          eta: e.average_duration,
          changed_state_ids: e.success ? e.output.changed_state_ids : void 0
        },
        data: e.success ? e.output : null
      };
    case "process_streaming":
      return {
        type: "streaming",
        status: {
          queue: !0,
          message: e.output.error,
          stage: "streaming",
          time_limit: e.time_limit,
          code: e.code,
          progress_data: e.progress_data,
          eta: e.eta
        },
        data: e.output
      };
    case "process_completed":
      return "error" in e.output ? {
        type: "update",
        status: {
          queue: !0,
          title: e.output.title,
          message: e.output.error,
          visible: e.output.visible,
          duration: e.output.duration,
          stage: "error",
          code: e.code,
          success: e.success
        }
      } : {
        type: "complete",
        status: {
          queue: !0,
          message: e.success ? void 0 : e.output.error,
          stage: e.success ? "complete" : "error",
          code: e.code,
          progress_data: e.progress_data,
          changed_state_ids: e.success ? e.output.changed_state_ids : void 0
        },
        data: e.success ? e.output : null
      };
    case "process_starts":
      return {
        type: "update",
        status: {
          queue: !0,
          stage: "pending",
          code: e.code,
          size: e.rank,
          position: 0,
          success: e.success,
          eta: e.eta
        },
        original_msg: "process_starts"
      };
  }
  return { type: "none", status: { stage: "error", queue: !0 } };
}
const Rt = (e = [], s) => {
  const t = s ? s.parameters : [];
  if (Array.isArray(e))
    return s && t.length > 0 && e.length > t.length && console.warn("Too many arguments provided for the endpoint."), e;
  const n = [], i = Object.keys(e);
  return t.forEach((r, o) => {
    if (e.hasOwnProperty(r.parameter_name))
      n[o] = e[r.parameter_name];
    else if (r.parameter_has_default)
      n[o] = r.parameter_default;
    else
      throw new Error(
        `No value provided for required parameter: ${r.parameter_name}`
      );
  }), i.forEach((r) => {
    if (!t.some((o) => o.parameter_name === r))
      throw new Error(
        `Parameter \`${r}\` is not a valid keyword argument. Please refer to the API for usage.`
      );
  }), n.forEach((r, o) => {
    if (r === void 0 && !t[o].parameter_has_default)
      throw new Error(
        `No value provided for required parameter: ${t[o].parameter_name}`
      );
  }), n;
};
async function Ot() {
  if (this.api_info) return this.api_info;
  const { token: e } = this.options, { config: s } = this, t = { "Content-Type": "application/json" };
  if (e && (t.Authorization = `Bearer ${e}`), !!s)
    try {
      let n, i;
      if (typeof window < "u" && window.gradio_api_info)
        i = window.gradio_api_info;
      else {
        const r = le(s.root, this.api_prefix, it);
        if (n = await this.fetch(r, {
          headers: t,
          credentials: "include"
        }), !n.ok)
          throw new Error(V);
        i = await n.json();
      }
      return "api" in i && (i = i.api), i.named_endpoints["/predict"] && !i.unnamed_endpoints[0] && (i.unnamed_endpoints[0] = i.named_endpoints["/predict"]), St(i, s, this.api_map);
    } catch (n) {
      throw new Error("Could not get API info. " + n.message);
    }
}
async function Tt(e, s, t) {
  var a;
  const n = {};
  (a = this == null ? void 0 : this.options) != null && a.token && (n.Authorization = `Bearer ${this.options.token}`);
  const i = 1e3, r = [];
  let o;
  for (let u = 0; u < s.length; u += i) {
    const h = s.slice(u, u + i), f = new FormData();
    h.forEach((g) => {
      f.append("files", g);
    });
    try {
      const g = t ? `${e}${this.api_prefix}/${Re}?upload_id=${t}` : `${e}${this.api_prefix}/${Re}`;
      o = await this.fetch(g, {
        method: "POST",
        body: f,
        headers: n,
        credentials: "include"
      });
    } catch (g) {
      throw new Error(V + g.message);
    }
    if (!o.ok) {
      const g = await o.text();
      return { error: `HTTP ${o.status}: ${g}` };
    }
    const p = await o.json();
    p && r.push(...p);
  }
  return { files: r };
}
async function At(e, s, t, n) {
  let i = (Array.isArray(e) ? e : [e]).map(
    (o) => o.blob
  );
  const r = i.filter(
    (o) => o.size > (n ?? 1 / 0)
  );
  if (r.length)
    throw new Error(
      `File size exceeds the maximum allowed size of ${n} bytes: ${r.map((o) => o.name).join(", ")}`
    );
  return await Promise.all(
    await this.upload_files(s, i, t).then(
      async (o) => {
        if (o.error)
          throw new Error(o.error);
        return o.files ? o.files.map((a, u) => new te({
          ...e[u],
          path: a,
          url: `${s}${this.api_prefix}/file=${a}`
        })) : [];
      }
    )
  );
}
async function ns(e, s) {
  return e.map(
    (t) => new te({
      path: t.name,
      orig_name: t.name,
      blob: t,
      size: t.size,
      mime_type: t.type,
      is_stream: s
    })
  );
}
class te {
  constructor({
    path: s,
    url: t,
    orig_name: n,
    size: i,
    blob: r,
    is_stream: o,
    mime_type: a,
    alt_text: u,
    b64: h
  }) {
    l(this, "path");
    l(this, "url");
    l(this, "orig_name");
    l(this, "size");
    l(this, "blob");
    l(this, "is_stream");
    l(this, "mime_type");
    l(this, "alt_text");
    l(this, "b64");
    l(this, "meta", { _type: "gradio.FileData" });
    this.path = s, this.url = t, this.orig_name = n, this.size = i, this.blob = t ? void 0 : r, this.is_stream = o, this.mime_type = a, this.alt_text = u, this.b64 = h;
  }
}
class ze {
  constructor(s, t) {
    l(this, "type");
    l(this, "command");
    l(this, "meta");
    l(this, "fileData");
    this.type = "command", this.command = s, this.meta = t;
  }
}
const Ct = typeof process < "u" && process.versions && process.versions.node;
function Ce(e, s, t) {
  for (; t.length > 1; ) {
    const i = t.shift();
    if (typeof i == "string" || typeof i == "number")
      e = e[i];
    else
      throw new Error("Invalid key type");
  }
  const n = t.shift();
  if (typeof n == "string" || typeof n == "number")
    e[n] = s;
  else
    throw new Error("Invalid key type");
}
async function pe(e, s = void 0, t = [], n = !1, i = void 0) {
  if (Array.isArray(e)) {
    let r = [];
    return await Promise.all(
      e.map(async (o, a) => {
        var f;
        let u = t.slice();
        u.push(String(a));
        const h = await pe(
          e[a],
          n ? ((f = i == null ? void 0 : i.parameters[a]) == null ? void 0 : f.component) || void 0 : s,
          u,
          !1,
          i
        );
        r = r.concat(h);
      })
    ), r;
  } else {
    if (globalThis.Buffer && e instanceof globalThis.Buffer || e instanceof Blob)
      return [
        {
          path: t,
          blob: new Blob([e]),
          type: s
        }
      ];
    if (typeof e == "object" && e !== null) {
      let r = [];
      for (const o of Object.keys(e)) {
        const a = [...t, o], u = e[o];
        r = r.concat(
          await pe(
            u,
            void 0,
            a,
            !1,
            i
          )
        );
      }
      return r;
    }
  }
  return [];
}
function Nt(e, s) {
  var n, i;
  let t = (i = (n = s == null ? void 0 : s.dependencies) == null ? void 0 : n.find((r) => r.id == e)) == null ? void 0 : i.queue;
  return t != null ? !t : !s.enable_queue;
}
function Dt(e, s) {
  return new Promise((t, n) => {
    const i = new MessageChannel();
    i.port1.onmessage = ({ data: r }) => {
      i.port1.close(), t(r);
    }, window.parent.postMessage(e, s, [i.port2]);
  });
}
function is(e) {
  if (typeof e == "string") {
    if (e.startsWith("http://") || e.startsWith("https://"))
      return {
        path: e,
        url: e,
        orig_name: e.split("/").pop() ?? "unknown",
        meta: { _type: "gradio.FileData" }
      };
    if (Ct)
      return new ze("upload_file", {
        path: e,
        name: e,
        orig_path: e
      });
  } else {
    if (typeof File < "u" && e instanceof File)
      return new Blob([e]);
    if (e instanceof Buffer)
      return new Blob([e]);
    if (e instanceof Blob)
      return e;
  }
  throw new Error(
    "Invalid input: must be a URL, File, Blob, or Buffer object."
  );
}
function Y(e, s, t, n, i = !1) {
  if (n === "input" && !i)
    throw new Error("Invalid code path. Cannot skip state inputs for input.");
  if (n === "output" && i)
    return e;
  let r = [], o = 0;
  const a = n === "input" ? s.inputs : s.outputs;
  for (let u = 0; u < a.length; u++) {
    const h = a[u], f = t.find((p) => p.id === h);
    if ((f == null ? void 0 : f.type) === "state") {
      if (i)
        if (e.length === a.length) {
          const p = e[o];
          r.push(p), o++;
        } else
          r.push(null);
      else {
        o++;
        continue;
      }
      continue;
    } else {
      const p = e[o];
      r.push(p), o++;
    }
  }
  return r;
}
async function Lt(e, s, t) {
  const n = this;
  await xt(n, s);
  const i = await pe(
    s,
    void 0,
    [],
    !0,
    t
  );
  return (await Promise.all(
    i.map(async ({ path: o, blob: a, type: u }) => {
      if (!a) return { path: o, type: u };
      const h = await n.upload_files(e, [a]), f = h.files && h.files[0];
      return {
        path: o,
        file_url: f,
        type: u,
        name: typeof File < "u" && a instanceof File ? a == null ? void 0 : a.name : void 0
      };
    })
  )).forEach(({ path: o, file_url: a, type: u, name: h }) => {
    if (u === "Gallery")
      Ce(s, a, o);
    else if (a) {
      const f = new te({ path: a, orig_name: h });
      Ce(s, f, o);
    }
  }), s;
}
async function xt(e, s) {
  var n, i;
  if (!(((n = e.config) == null ? void 0 : n.root) || ((i = e.config) == null ? void 0 : i.root_url)))
    throw new Error(Ue);
  await Be(e, s);
}
async function Be(e, s, t = []) {
  for (const n in s)
    s[n] instanceof ze ? await It(e, s, n) : typeof s[n] == "object" && s[n] !== null && await Be(e, s[n], [...t, n]);
}
async function It(e, s, t) {
  var r, o;
  let n = s[t];
  const i = ((r = e.config) == null ? void 0 : r.root) || ((o = e.config) == null ? void 0 : o.root_url);
  if (!i)
    throw new Error(Ue);
  try {
    let a, u;
    if (typeof process < "u" && process.versions && process.versions.node) {
      const g = await import("./__vite-browser-external-DYxpcVy9.js");
      u = (await import("./__vite-browser-external-DYxpcVy9.js")).resolve(process.cwd(), n.meta.path), a = await g.readFile(u);
    } else
      throw new Error(mt);
    const h = new Blob([a], { type: "application/octet-stream" }), f = await e.upload_files(i, [h]), p = f.files && f.files[0];
    if (p) {
      const g = new te({
        path: p,
        orig_name: n.meta.name || ""
      });
      s[t] = g;
    }
  } catch (a) {
    console.error(wt, a);
  }
}
async function Pt(e, s, t) {
  const n = { "Content-Type": "application/json" };
  this.options.token && (n.Authorization = `Bearer ${this.options.token}`);
  try {
    var i = await this.fetch(e, {
      method: "POST",
      body: JSON.stringify(s),
      headers: { ...n, ...t },
      credentials: "include"
    });
  } catch {
    return [{ error: V }, 500];
  }
  let r, o;
  try {
    r = await i.json(), o = i.status;
  } catch (a) {
    r = { error: `Could not parse server response: ${a}` }, o = 500;
  }
  return [r, o];
}
async function Ut(e, s = {}) {
  let t = !1, n = !1;
  if (!this.config)
    throw new Error("Could not resolve app config");
  if (typeof e == "number")
    this.config.dependencies.find((i) => i.id == e);
  else {
    const i = e.replace(/^\//, "");
    this.config.dependencies.find(
      (r) => r.id == this.api_map[i]
    );
  }
  return new Promise(async (i, r) => {
    const o = this.submit(e, s, null, null, !0);
    let a;
    for await (const u of o)
      u.type === "data" && (n && i(a), t = !0, a = u), u.type === "status" && (u.stage === "error" && r(u), u.stage === "complete" && (n = !0, t && i(a)));
  });
}
async function W(e, s, t) {
  let n = s === "subdomain" ? `https://huggingface.co/api/spaces/by-subdomain/${e}` : `https://huggingface.co/api/spaces/${e}`, i, r;
  try {
    if (i = await fetch(n), r = i.status, r !== 200)
      throw new Error();
    i = await i.json();
  } catch {
    t({
      status: "error",
      load_status: "error",
      message: ht,
      detail: "NOT_FOUND"
    });
    return;
  }
  if (!i || r !== 200) return;
  const {
    runtime: { stage: o },
    id: a
  } = i;
  switch (o) {
    case "STOPPED":
    case "SLEEPING":
      t({
        status: "sleeping",
        load_status: "pending",
        message: "Space is asleep. Waking it up...",
        detail: o
      }), setTimeout(() => {
        W(e, s, t);
      }, 1e3);
      break;
    case "PAUSED":
      t({
        status: "paused",
        load_status: "error",
        message: "This space has been paused by the author. If you would like to try this demo, consider duplicating the space.",
        detail: o,
        discussions_enabled: await Ne(a)
      });
      break;
    case "RUNNING":
    case "RUNNING_BUILDING":
      t({
        status: "running",
        load_status: "complete",
        message: "Space is running.",
        detail: o
      });
      break;
    case "BUILDING":
      t({
        status: "building",
        load_status: "pending",
        message: "Space is building...",
        detail: o
      }), setTimeout(() => {
        W(e, s, t);
      }, 1e3);
      break;
    case "APP_STARTING":
      t({
        status: "starting",
        load_status: "pending",
        message: "Space is starting...",
        detail: o
      }), setTimeout(() => {
        W(e, s, t);
      }, 1e3);
      break;
    default:
      t({
        status: "space_error",
        load_status: "error",
        message: "This space is experiencing an issue.",
        detail: o,
        discussions_enabled: await Ne(a)
      });
      break;
  }
}
const Fe = async (e, s) => {
  let t = 0;
  const n = 12, i = 5e3;
  return new Promise((r) => {
    W(
      e,
      fe.test(e) ? "space_name" : "subdomain",
      (o) => {
        s(o), o.status === "running" || o.status === "error" || o.status === "paused" || o.status === "space_error" ? r() : (o.status === "sleeping" || o.status === "building") && (t < n ? (t++, setTimeout(() => {
          Fe(e, s).then(r);
        }, i)) : r());
      }
    );
  });
}, jt = /^(?=[^]*\b[dD]iscussions{0,1}\b)(?=[^]*\b[dD]isabled\b)[^]*$/;
async function Ne(e) {
  try {
    const s = await fetch(
      `https://huggingface.co/api/spaces/${e}/discussions`,
      {
        method: "HEAD"
      }
    ), t = s.headers.get("x-error-message");
    return !(!s.ok || t && jt.test(t));
  } catch {
    return !1;
  }
}
async function qt(e, s) {
  const t = {};
  s && (t.Authorization = `Bearer ${s}`);
  try {
    const n = await fetch(
      `https://huggingface.co/api/spaces/${e}/${ot}`,
      { headers: t }
    );
    if (n.status !== 200)
      throw new Error("Space hardware could not be obtained.");
    const { hardware: i } = await n.json();
    return i.current;
  } catch (n) {
    throw new Error(n.message);
  }
}
async function zt(e, s, t) {
  const n = {};
  t && (n.Authorization = `Bearer ${t}`);
  const i = {
    seconds: s
  };
  try {
    const r = await fetch(
      `https://huggingface.co/api/spaces/${e}/${rt}`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json", ...n },
        body: JSON.stringify(i)
      }
    );
    if (r.status !== 200)
      throw new Error(
        "Could not set sleep timeout on duplicated Space. Please visit *ADD HF LINK TO SETTINGS* to set a timeout manually to reduce billing charges."
      );
    return await r.json();
  } catch (r) {
    throw new Error(r.message);
  }
}
const De = [
  "cpu-basic",
  "cpu-upgrade",
  "cpu-xl",
  "t4-small",
  "t4-medium",
  "a10g-small",
  "a10g-large",
  "a10g-largex2",
  "a10g-largex4",
  "a100-large",
  "zero-a10g",
  "h100",
  "h100x8"
];
async function Bt(e, s) {
  const { token: t, private: n, hardware: i, timeout: r, auth: o } = s;
  if (i && !De.includes(i))
    throw new Error(
      `Invalid hardware type provided. Valid types are: ${De.map((_) => `"${_}"`).join(",")}.`
    );
  const { http_protocol: a, host: u } = await de(e, t);
  let h = null;
  if (o) {
    const _ = await je(
      a,
      u,
      o,
      fetch
    );
    _ && (h = qe(_));
  }
  const f = {
    Authorization: `Bearer ${t}`,
    "Content-Type": "application/json",
    ...h ? { Cookie: h.join("; ") } : {}
  }, p = (await (await fetch("https://huggingface.co/api/whoami-v2", {
    headers: f
  })).json()).name, g = e.split("/")[1], v = {
    repository: `${p}/${g}`
  };
  n && (v.private = !0);
  let P;
  try {
    i || (P = await qt(e, t));
  } catch (_) {
    throw Error(he + _.message);
  }
  const c = i || P || "cpu-basic";
  v.hardware = c;
  try {
    const _ = await fetch(
      `https://huggingface.co/api/spaces/${e}/duplicate`,
      {
        method: "POST",
        headers: f,
        body: JSON.stringify(v)
      }
    );
    if (_.status === 409)
      try {
        return await ee.connect(`${p}/${g}`, s);
      } catch (R) {
        throw console.error("Failed to connect Client instance:", R), R;
      }
    else if (_.status !== 200)
      throw new Error(_.statusText);
    const S = await _.json();
    return await zt(`${p}/${g}`, r || 300, t), await ee.connect(
      Ft(S.url),
      s
    );
  } catch (_) {
    throw new Error(_);
  }
}
function Ft(e) {
  const s = /https:\/\/huggingface.co\/spaces\/([^/]+\/[^/]+)/, t = e.match(s);
  if (t)
    return t[1];
}
var C;
class Gt extends TransformStream {
  /** Constructs a new instance. */
  constructor(t = { allowCR: !1 }) {
    super({
      transform: (n, i) => {
        for (n = B(this, C) + n; ; ) {
          const r = n.indexOf(`
`), o = t.allowCR ? n.indexOf("\r") : -1;
          if (o !== -1 && o !== n.length - 1 && (r === -1 || r - 1 > o)) {
            i.enqueue(n.slice(0, o)), n = n.slice(o + 1);
            continue;
          }
          if (r === -1)
            break;
          const a = n[r - 1] === "\r" ? r - 1 : r;
          i.enqueue(n.slice(0, a)), n = n.slice(r + 1);
        }
        ke(this, C, n);
      },
      flush: (n) => {
        if (B(this, C) === "")
          return;
        const i = t.allowCR && B(this, C).endsWith("\r") ? B(this, C).slice(0, -1) : B(this, C);
        n.enqueue(i);
      }
    });
    $e(this, C, "");
  }
}
C = new WeakMap();
function Mt(e) {
  let s = new TextDecoderStream(), t = new Gt({ allowCR: !0 });
  return e.pipeThrough(s).pipeThrough(t);
}
function Jt(e) {
  let t = /[:]\s*/.exec(e), n = t && t.index;
  if (n)
    return [
      e.substring(0, n),
      e.substring(n + t[0].length)
    ];
}
function Le(e, s, t) {
  e.get(s) || e.set(s, t);
}
async function* Ht(e, s) {
  if (!e.body)
    return;
  let t = Mt(e.body), n, i = t.getReader(), r;
  for (; ; ) {
    if (s && s.aborted)
      return i.cancel();
    if (n = await i.read(), n.done)
      return;
    if (!n.value) {
      r && (yield r), r = void 0;
      continue;
    }
    let [o, a] = Jt(n.value) || [];
    o && (o === "data" ? (r || (r = {}), r[o] = r[o] ? r[o] + `
` + a : a) : o === "event" ? (r || (r = {}), r[o] = a) : o === "id" ? (r || (r = {}), r[o] = +a || a) : o === "retry" && (r || (r = {}), r[o] = +a || void 0));
  }
}
async function Wt(e, s) {
  let t = new Request(e, s);
  Le(t.headers, "Accept", "text/event-stream"), Le(t.headers, "Content-Type", "application/json");
  let n = await fetch(t);
  if (!n.ok)
    throw n;
  return Ht(n, t.signal);
}
async function Vt() {
  let {
    event_callbacks: e,
    unclosed_events: s,
    pending_stream_messages: t,
    stream_status: n,
    config: i,
    jwt: r
  } = this;
  const o = this;
  if (!i)
    throw new Error("Could not resolve app config");
  n.open = !0;
  let a = null, u = new URLSearchParams({
    session_hash: this.session_hash
  }).toString(), h = new URL(`${i.root}${this.api_prefix}/${xe}?${u}`);
  if (r && h.searchParams.set("__sign", r), a = this.stream(h), !a) {
    console.warn("Cannot connect to SSE endpoint: " + h.toString());
    return;
  }
  a.onmessage = async function(f) {
    let p = JSON.parse(f.data);
    if (p.msg === "close_stream") {
      _e(n, o.abort_controller);
      return;
    }
    const g = p.event_id;
    if (!g)
      await Promise.all(
        Object.keys(e).map(
          (v) => e[v](p)
        )
      );
    else if (e[g] && i) {
      p.msg === "process_completed" && ["sse", "sse_v1", "sse_v2", "sse_v2.1", "sse_v3"].includes(
        i.protocol
      ) && s.delete(g);
      let v = e[g];
      typeof window < "u" && typeof document < "u" ? setTimeout(v, 0, p) : v(p);
    } else
      t[g] || (t[g] = []), t[g].push(p);
  }, a.onerror = async function(f) {
    console.error(f), await Promise.all(
      Object.keys(e).map(
        (p) => e[p]({
          msg: "broken_connection",
          message: V
        })
      )
    );
  };
}
function _e(e, s) {
  e && (e.open = !1, s == null || s.abort());
}
function Zt(e, s, t) {
  !e[s] ? (e[s] = [], t.data.forEach((i, r) => {
    e[s][r] = i;
  })) : t.data.forEach((i, r) => {
    let o = Kt(e[s][r], i);
    e[s][r] = o, t.data[r] = o;
  });
}
function Kt(e, s) {
  return s.forEach(([t, n, i]) => {
    e = Qt(e, n, t, i);
  }), e;
}
function Qt(e, s, t, n) {
  if (s.length === 0) {
    if (t === "replace")
      return n;
    if (t === "append")
      return e + n;
    throw new Error(`Unsupported action: ${t}`);
  }
  let i = e;
  for (let o = 0; o < s.length - 1; o++)
    i = i[s[o]];
  const r = s[s.length - 1];
  switch (t) {
    case "replace":
      i[r] = n;
      break;
    case "append":
      i[r] += n;
      break;
    case "add":
      Array.isArray(i) ? i.splice(Number(r), 0, n) : i[r] = n;
      break;
    case "delete":
      Array.isArray(i) ? i.splice(Number(r), 1) : delete i[r];
      break;
    default:
      throw new Error(`Unknown action: ${t}`);
  }
  return e;
}
function Xt(e, s = {}) {
  const t = {
    close: () => {
      console.warn("Method not implemented.");
    },
    onerror: null,
    onmessage: null,
    onopen: null,
    readyState: 0,
    url: e.toString(),
    withCredentials: !1,
    CONNECTING: 0,
    OPEN: 1,
    CLOSED: 2,
    addEventListener: () => {
      throw new Error("Method not implemented.");
    },
    dispatchEvent: () => {
      throw new Error("Method not implemented.");
    },
    removeEventListener: () => {
      throw new Error("Method not implemented.");
    }
  };
  return Wt(e, s).then(async (n) => {
    t.readyState = t.OPEN;
    try {
      for await (const i of n)
        t.onmessage && t.onmessage(i);
      t.readyState = t.CLOSED;
    } catch (i) {
      t.onerror && t.onerror(i), t.readyState = t.CLOSED;
    }
  }).catch((n) => {
    console.error(n), t.onerror && t.onerror(n), t.readyState = t.CLOSED;
  }), t;
}
function Yt(e, s = {}, t, n, i) {
  var r;
  try {
    let o = function(m) {
      (i || We[m.type]) && f(m);
    }, a = function() {
      for (Ke = !0; M.length > 0; )
        M.shift()({
          value: void 0,
          done: !0
        });
    }, u = function(m) {
      M.length > 0 ? M.shift()(m) : ae.push(m);
    }, h = function(m) {
      u(es(m)), a();
    }, f = function(m) {
      u({ value: m, done: !1 });
    }, p = function() {
      return ae.length > 0 ? Promise.resolve(ae.shift()) : new Promise((m) => M.push(m));
    };
    const { token: g } = this.options, {
      fetch: v,
      app_reference: P,
      config: c,
      session_hash: _,
      api_info: S,
      api_map: R,
      stream_status: se,
      pending_stream_messages: ne,
      pending_diff_streams: ie,
      event_callbacks: oe,
      unclosed_events: Ge,
      post_data: re,
      options: U,
      api_prefix: j
    } = this, Me = this;
    if (!S) throw new Error("No API found");
    if (!c) throw new Error("Could not resolve app config");
    let { fn_index: d, endpoint_info: ge, dependency: F } = ts(
      S,
      e,
      R,
      c
    ), Je = Rt(s, ge), $, N = c.protocol ?? "ws";
    if (N === "ws")
      throw new Error("WebSocket protocol is not supported in this version");
    let me = "", He = () => me;
    const w = typeof e == "number" ? "/predict" : e;
    let Z, E = null, D = !1, we = {}, G = typeof window < "u" && typeof document < "u" ? new URLSearchParams(window.location.search).toString() : "";
    const We = ((r = U == null ? void 0 : U.events) == null ? void 0 : r.reduce(
      (m, A) => (m[A] = !0, m),
      {}
    )) || {};
    async function Ve() {
      let m = {}, A = {};
      m = { event_id: E }, A = { event_id: E, session_hash: _, fn_index: d };
      try {
        if (!c)
          throw new Error("Could not resolve app config");
        "event_id" in A && await v(`${c.root}${j}/${lt}`, {
          headers: { "Content-Type": "application/json" },
          method: "POST",
          body: JSON.stringify(A)
        }), await v(`${c.root}${j}/${ut}`, {
          headers: { "Content-Type": "application/json" },
          method: "POST",
          body: JSON.stringify(m)
        });
      } catch {
        console.warn(
          "The `/reset` endpoint could not be called. Subsequent endpoint results may be unreliable."
        );
      }
    }
    const Ze = async (m) => {
      await this._resolve_heartbeat(m);
    };
    async function ye(m) {
      if (!c) return;
      let A = m.render_id;
      c.components = [
        ...c.components.filter((b) => b.props.rendered_in !== A),
        ...m.components
      ], c.dependencies = [
        ...c.dependencies.filter((b) => b.rendered_in !== A),
        ...m.dependencies
      ];
      const K = c.components.some((b) => b.type === "state"), Q = c.dependencies.some(
        (b) => b.targets.some((q) => q[1] === "unload")
      );
      c.connect_heartbeat = K || Q, await Ze(c), o({
        type: "render",
        data: m,
        endpoint: w,
        fn_index: d
      });
    }
    this.handle_blob(c.root, Je, ge).then(
      async (m) => {
        var Q;
        if (Z = {
          data: Y(
            m,
            F,
            c.components,
            "input",
            !0
          ) || [],
          event_data: t,
          fn_index: d,
          trigger_id: n
        }, Nt(d, c))
          o({
            type: "status",
            endpoint: w,
            stage: "pending",
            queue: !1,
            fn_index: d,
            time: /* @__PURE__ */ new Date()
          }), re(
            `${c.root}${j}/run${w.startsWith("/") ? w : `/${w}`}${G ? "?" + G : ""}`,
            {
              ...Z,
              session_hash: _
            }
          ).then(([b, q]) => {
            const J = b.data;
            q == 200 ? (o({
              type: "data",
              endpoint: w,
              fn_index: d,
              data: Y(
                J,
                F,
                c.components,
                "output",
                U.with_null_state
              ),
              time: /* @__PURE__ */ new Date(),
              event_data: t,
              trigger_id: n
            }), b.render_config && ye(b.render_config), o({
              type: "status",
              endpoint: w,
              fn_index: d,
              stage: "complete",
              eta: b.average_duration,
              queue: !1,
              time: /* @__PURE__ */ new Date()
            })) : o({
              type: "status",
              stage: "error",
              endpoint: w,
              fn_index: d,
              message: b.error,
              queue: !1,
              time: /* @__PURE__ */ new Date()
            });
          }).catch((b) => {
            o({
              type: "status",
              stage: "error",
              message: b.message,
              endpoint: w,
              fn_index: d,
              queue: !1,
              time: /* @__PURE__ */ new Date()
            });
          });
        else if (N == "sse") {
          o({
            type: "status",
            stage: "pending",
            queue: !0,
            endpoint: w,
            fn_index: d,
            time: /* @__PURE__ */ new Date()
          });
          var K = new URLSearchParams({
            fn_index: d.toString(),
            session_hash: _
          }).toString();
          let b = new URL(
            `${c.root}${j}/${xe}?${G ? G + "&" : ""}${K}`
          );
          if (this.jwt && b.searchParams.set("__sign", this.jwt), $ = this.stream(b), !$)
            return Promise.reject(
              new Error("Cannot connect to SSE endpoint: " + b.toString())
            );
          $.onmessage = async function(q) {
            const J = JSON.parse(q.data), { type: I, status: k, data: L } = Ae(
              J,
              we[d]
            );
            if (I === "update" && k && !D)
              o({
                type: "status",
                endpoint: w,
                fn_index: d,
                time: /* @__PURE__ */ new Date(),
                ...k
              }), k.stage === "error" && ($ == null || $.close(), a());
            else if (I === "data") {
              let [z, H] = await re(
                `${c.root}${j}/queue/data`,
                {
                  ...Z,
                  session_hash: _,
                  event_id: E
                }
              );
              H !== 200 && (o({
                type: "status",
                stage: "error",
                message: V,
                queue: !0,
                endpoint: w,
                fn_index: d,
                time: /* @__PURE__ */ new Date()
              }), $ == null || $.close(), a());
            } else I === "complete" ? D = k : I === "log" ? o({
              type: "log",
              title: L.title,
              log: L.log,
              level: L.level,
              endpoint: w,
              duration: L.duration,
              visible: L.visible,
              fn_index: d
            }) : (I === "generating" || I === "streaming") && o({
              type: "status",
              time: /* @__PURE__ */ new Date(),
              ...k,
              stage: k == null ? void 0 : k.stage,
              queue: !0,
              endpoint: w,
              fn_index: d
            });
            L && (o({
              type: "data",
              time: /* @__PURE__ */ new Date(),
              data: Y(
                L.data,
                F,
                c.components,
                "output",
                U.with_null_state
              ),
              endpoint: w,
              fn_index: d,
              event_data: t,
              trigger_id: n
            }), D && (o({
              type: "status",
              time: /* @__PURE__ */ new Date(),
              ...D,
              stage: k == null ? void 0 : k.stage,
              queue: !0,
              endpoint: w,
              fn_index: d
            }), $ == null || $.close(), a()));
          };
        } else if (N == "sse_v1" || N == "sse_v2" || N == "sse_v2.1" || N == "sse_v3") {
          o({
            type: "status",
            stage: "pending",
            queue: !0,
            endpoint: w,
            fn_index: d,
            time: /* @__PURE__ */ new Date()
          });
          let b = "";
          typeof window < "u" && typeof document < "u" && (b = (Q = window == null ? void 0 : window.location) == null ? void 0 : Q.hostname);
          const J = b.includes(".dev.") ? `https://moon-${b.split(".")[1]}.dev.spaces.huggingface.tech` : "https://huggingface.co";
          (typeof window < "u" && typeof document < "u" && window.parent != window && window.supports_zerogpu_headers ? Dt("zerogpu-headers", J) : Promise.resolve(null)).then((z) => re(
            `${c.root}${j}/${st}?${G}`,
            {
              ...Z,
              session_hash: _
            },
            z
          )).then(async ([z, H]) => {
            if (H === 503)
              o({
                type: "status",
                stage: "error",
                message: Ie,
                queue: !0,
                endpoint: w,
                fn_index: d,
                time: /* @__PURE__ */ new Date()
              });
            else if (H === 422)
              o({
                type: "status",
                stage: "error",
                message: z.detail,
                queue: !0,
                endpoint: w,
                fn_index: d,
                code: "validation_error",
                time: /* @__PURE__ */ new Date()
              }), a();
            else if (H !== 200)
              o({
                type: "status",
                stage: "error",
                broken: !1,
                message: z.detail,
                queue: !0,
                endpoint: w,
                fn_index: d,
                time: /* @__PURE__ */ new Date()
              });
            else {
              E = z.event_id, me = E;
              let ve = async function(ce) {
                try {
                  const { type: O, status: y, data: T, original_msg: Qe } = Ae(
                    ce,
                    we[d]
                  );
                  if (O == "heartbeat")
                    return;
                  if (O === "update" && y && !D)
                    o({
                      type: "status",
                      endpoint: w,
                      fn_index: d,
                      time: /* @__PURE__ */ new Date(),
                      original_msg: Qe,
                      ...y
                    });
                  else if (O === "complete")
                    D = y;
                  else if (O == "unexpected_error" || O == "broken_connection") {
                    console.error("Unexpected error", y == null ? void 0 : y.message);
                    const Xe = O === "broken_connection";
                    o({
                      type: "status",
                      stage: "error",
                      message: (y == null ? void 0 : y.message) || "An Unexpected Error Occurred!",
                      queue: !0,
                      endpoint: w,
                      broken: Xe,
                      session_not_found: y == null ? void 0 : y.session_not_found,
                      fn_index: d,
                      time: /* @__PURE__ */ new Date()
                    });
                  } else if (O === "log") {
                    o({
                      type: "log",
                      title: T.title,
                      log: T.log,
                      level: T.level,
                      endpoint: w,
                      duration: T.duration,
                      visible: T.visible,
                      fn_index: d
                    });
                    return;
                  } else (O === "generating" || O === "streaming") && (o({
                    type: "status",
                    time: /* @__PURE__ */ new Date(),
                    ...y,
                    stage: y == null ? void 0 : y.stage,
                    queue: !0,
                    endpoint: w,
                    fn_index: d
                  }), T && F.connection !== "stream" && ["sse_v2", "sse_v2.1", "sse_v3"].includes(N) && Zt(ie, E, T));
                  T && (o({
                    type: "data",
                    time: /* @__PURE__ */ new Date(),
                    data: Y(
                      T.data,
                      F,
                      c.components,
                      "output",
                      U.with_null_state
                    ),
                    endpoint: w,
                    fn_index: d
                  }), T.render_config && await ye(T.render_config), D && (o({
                    type: "status",
                    time: /* @__PURE__ */ new Date(),
                    ...D,
                    stage: y == null ? void 0 : y.stage,
                    queue: !0,
                    endpoint: w,
                    fn_index: d
                  }), a())), ((y == null ? void 0 : y.stage) === "complete" || (y == null ? void 0 : y.stage) === "error") && (oe[E] && delete oe[E], E in ie && delete ie[E]);
                } catch (O) {
                  console.error("Unexpected client exception", O), o({
                    type: "status",
                    stage: "error",
                    message: "An Unexpected Error Occurred!",
                    queue: !0,
                    endpoint: w,
                    fn_index: d,
                    time: /* @__PURE__ */ new Date()
                  }), ["sse_v2", "sse_v2.1", "sse_v3"].includes(N) && (_e(se, Me.abort_controller), se.open = !1, a());
                }
              };
              E in ne && (ne[E].forEach(
                (ce) => ve(ce)
              ), delete ne[E]), oe[E] = ve, Ge.add(E), se.open || await this.open_stream();
            }
          });
        }
      }
    );
    let Ke = !1;
    const ae = [], M = [], be = {
      [Symbol.asyncIterator]: () => be,
      next: p,
      throw: async (m) => (h(m), p()),
      return: async () => (a(), p()),
      cancel: Ve,
      event_id: He
    };
    return be;
  } catch (o) {
    throw console.error("Submit function encountered an error:", o), o;
  }
}
function es(e) {
  return {
    then: (s, t) => t(e)
  };
}
function ts(e, s, t, n) {
  let i, r, o;
  if (typeof s == "number")
    i = s, r = e.unnamed_endpoints[i], o = n.dependencies.find((a) => a.id == s);
  else {
    const a = s.replace(/^\//, "");
    i = t[a], r = e.named_endpoints[s.trim()], o = n.dependencies.find(
      (u) => u.id == t[a]
    );
  }
  if (typeof i != "number")
    throw new Error(
      "There is no endpoint matching that name of fn_index matching that number."
    );
  return { fn_index: i, endpoint_info: r, dependency: o };
}
class ee {
  constructor(s, t = { events: ["data"] }) {
    l(this, "app_reference");
    l(this, "options");
    l(this, "deep_link", null);
    l(this, "config");
    l(this, "api_prefix", "");
    l(this, "api_info");
    l(this, "api_map", {});
    l(this, "session_hash", Math.random().toString(36).substring(2));
    l(this, "jwt", !1);
    l(this, "last_status", {});
    l(this, "cookies", null);
    // streaming
    l(this, "stream_status", { open: !1 });
    l(this, "closed", !1);
    l(this, "pending_stream_messages", {});
    l(this, "pending_diff_streams", {});
    l(this, "event_callbacks", {});
    l(this, "unclosed_events", /* @__PURE__ */ new Set());
    l(this, "heartbeat_event", null);
    l(this, "abort_controller", null);
    l(this, "stream_instance", null);
    l(this, "current_payload");
    l(this, "view_api");
    l(this, "upload_files");
    l(this, "upload");
    l(this, "handle_blob");
    l(this, "post_data");
    l(this, "submit");
    l(this, "predict");
    l(this, "open_stream");
    l(this, "resolve_config");
    l(this, "resolve_cookies");
    var n;
    this.app_reference = s, this.deep_link = ((n = t.query_params) == null ? void 0 : n.deep_link) || null, t.events || (t.events = ["data"]), this.options = t, this.current_payload = {}, this.view_api = Ot.bind(this), this.upload_files = Tt.bind(this), this.handle_blob = Lt.bind(this), this.post_data = Pt.bind(this), this.submit = Yt.bind(this), this.predict = Ut.bind(this), this.open_stream = Vt.bind(this), this.resolve_config = bt.bind(this), this.resolve_cookies = vt.bind(this), this.upload = At.bind(this), this.fetch = this.fetch.bind(this), this.handle_space_success = this.handle_space_success.bind(this), this.stream = this.stream.bind(this);
  }
  get_url_config(s = null) {
    if (!this.config)
      throw new Error(x);
    s === null && (s = window.location.href);
    const t = (o) => o.replace(/^\/+|\/+$/g, "");
    let n = t(new URL(this.config.root).pathname), i = t(new URL(s).pathname), r;
    return i.startsWith(n) ? r = t(i.substring(n.length)) : r = "", this.get_page_config(r);
  }
  get_page_config(s) {
    if (!this.config)
      throw new Error(x);
    let t = this.config;
    return s in t.page || (s = ""), {
      ...t,
      current_page: s,
      layout: t.page[s].layout,
      components: t.components.filter(
        (n) => t.page[s].components.includes(n.id)
      ),
      dependencies: this.config.dependencies.filter(
        (n) => t.page[s].dependencies.includes(n.id)
      )
    };
  }
  fetch(s, t) {
    const n = new Headers((t == null ? void 0 : t.headers) || {});
    if (this && this.cookies && n.append("Cookie", this.cookies), this && this.options.headers)
      for (const i in this.options.headers)
        n.append(i, this.options.headers[i]);
    return fetch(s, { ...t, headers: n });
  }
  stream(s) {
    const t = new Headers();
    if (this && this.cookies && t.append("Cookie", this.cookies), this && this.options.headers)
      for (const n in this.options.headers)
        t.append(n, this.options.headers[n]);
    return this && this.options.token && t.append("Authorization", `Bearer ${this.options.token}`), this.abort_controller = new AbortController(), this.stream_instance = Xt(s.toString(), {
      credentials: "include",
      headers: t,
      signal: this.abort_controller.signal
    }), this.stream_instance;
  }
  async init() {
    var s;
    this.options.auth && await this.resolve_cookies(), await this._resolve_config().then(
      ({ config: t }) => this._resolve_heartbeat(t)
    ), this.api_info = await this.view_api(), this.api_map = yt(((s = this.config) == null ? void 0 : s.dependencies) || []);
  }
  async _resolve_heartbeat(s) {
    if (s && (this.config = s, this.api_prefix = s.api_prefix || "", this.config && this.config.connect_heartbeat && this.config.space_id && this.options.token && (this.jwt = await Oe(
      this.config.space_id,
      this.options.token,
      this.cookies
    ))), s.space_id && this.options.token && (this.jwt = await Oe(s.space_id, this.options.token)), this.config && this.config.connect_heartbeat) {
      const t = new URL(
        `${this.config.root}${this.api_prefix}/${at}/${this.session_hash}`
      );
      this.jwt && t.searchParams.set("__sign", this.jwt), this.heartbeat_event || (this.heartbeat_event = this.stream(t));
    }
  }
  static async connect(s, t = {
    events: ["data"]
  }) {
    const n = new this(s, t);
    return t.session_hash && (n.session_hash = t.session_hash), await n.init(), n;
  }
  async reconnect() {
    const s = new URL(
      `${this.config.root}${this.api_prefix}/${pt}`
    );
    let t;
    try {
      const n = await this.fetch(s);
      if (!n.ok)
        throw new Error();
      t = (await n.json()).app_id;
    } catch {
      return "broken";
    }
    return t !== this.config.app_id ? "changed" : "connected";
  }
  close() {
    this.closed = !0, _e(this.stream_status, this.abort_controller);
  }
  set_current_payload(s) {
    this.current_payload = s;
  }
  static async duplicate(s, t = {
    events: ["data"]
  }) {
    return Bt(s, t);
  }
  async _resolve_config() {
    const { http_protocol: s, host: t, space_id: n } = await de(
      this.app_reference,
      this.options.token
    ), { status_callback: i } = this.options;
    n && i && await Fe(n, i);
    let r;
    try {
      let o = `${s}//${t}`;
      if (r = await this.resolve_config(o), !r)
        throw new Error(x);
      return this.config_success(r);
    } catch (o) {
      if (n && i)
        W(
          n,
          fe.test(n) ? "space_name" : "subdomain",
          this.handle_space_success
        );
      else
        throw i && i({
          status: "error",
          message: "Could not load this space.",
          load_status: "error",
          detail: "NOT_FOUND"
        }), Error(o);
    }
  }
  async config_success(s) {
    if (this.config = s, this.api_prefix = s.api_prefix || "", this.config.auth_required)
      return this.prepare_return_obj();
    try {
      this.api_info = await this.view_api();
    } catch (t) {
      console.error(ft + t.message);
    }
    return this.prepare_return_obj();
  }
  async handle_space_success(s) {
    var n;
    if (!this)
      throw new Error(x);
    const { status_callback: t } = this.options;
    if (t && t(s), s.status === "running")
      try {
        if (this.config = await this._resolve_config(), this.api_prefix = ((n = this == null ? void 0 : this.config) == null ? void 0 : n.api_prefix) || "", !this.config)
          throw new Error(x);
        return await this.config_success(this.config);
      } catch (i) {
        throw t && t({
          status: "error",
          message: "Could not load this space.",
          load_status: "error",
          detail: "NOT_FOUND"
        }), i;
      }
  }
  async component_server(s, t, n) {
    var f;
    if (!this.config)
      throw new Error(x);
    const i = {}, { token: r } = this.options, { session_hash: o } = this;
    r && (i.Authorization = `Bearer ${this.options.token}`);
    let a, u = this.config.components.find(
      (p) => p.id === s
    );
    (f = u == null ? void 0 : u.props) != null && f.root_url ? a = u.props.root_url : a = this.config.root;
    let h;
    if ("binary" in n) {
      h = new FormData();
      for (const p in n.data)
        p !== "binary" && h.append(p, n.data[p]);
      h.set("component_id", s.toString()), h.set("fn_name", t), h.set("session_hash", o);
    } else
      h = JSON.stringify({
        data: n,
        component_id: s,
        fn_name: t,
        session_hash: o
      }), i["Content-Type"] = "application/json";
    r && (i.Authorization = `Bearer ${r}`);
    try {
      const p = await this.fetch(
        `${a}${this.api_prefix}/${ct}/`,
        {
          method: "POST",
          body: h,
          headers: i,
          credentials: "include"
        }
      );
      if (!p.ok)
        throw new Error(
          "Could not connect to component server: " + p.statusText
        );
      return await p.json();
    } catch (p) {
      console.warn(p);
    }
  }
  set_cookies(s) {
    this.cookies = qe(s).join("; ");
  }
  prepare_return_obj() {
    return {
      config: this.config,
      predict: this.predict,
      submit: this.submit,
      view_api: this.view_api,
      component_server: this.component_server
    };
  }
}
async function os(e, s = {
  events: ["data"]
}) {
  return await ee.connect(e, s);
}
async function rs(e, s) {
  return await ee.duplicate(e, s);
}
export {
  ee as Client,
  te as FileData,
  gt as MISSING_CREDENTIALS_MSG,
  os as client,
  rs as duplicate,
  is as handle_file,
  Ut as predict,
  ns as prepare_files,
  Yt as submit,
  At as upload,
  Tt as upload_files
};
